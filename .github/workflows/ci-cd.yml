name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: spacex-fullstack
  ECS_SERVICE: spacex-fullstack-service
  ECS_CLUSTER: spacex-cluster
  ECS_TASK_DEFINITION: spacex-task-def
  CONTAINER_NAME: spacex-app

jobs:
  # ==================================================
  # Job 1: Test Lambda/Src Code
  # ==================================================
  test-lambda:
    name: Test Lambda Functions
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install Lambda dependencies
        run: |
          cd src
          pip install -r requirements.txt
          pip install pytest pytest-cov

      - name: Run Lambda tests
        run: |
          cd src
          python -m pytest tests/ -v --cov=. --cov-report=term-missing
        
      - name: Upload coverage reports
        if: always()
        uses: codecov/codecov-action@v4
        with:
          files: ./src/.coverage
          flags: lambda
          name: lambda-coverage
        continue-on-error: true

  # ==================================================
  # Job 2: Test Backend API
  # ==================================================
  test-backend:
    name: Test Backend API
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install Backend dependencies
        run: |
          cd backend
          pip install -r requirements.txt
          pip install pytest pytest-cov

      - name: Run Backend tests
        run: |
          cd backend
          python -m pytest app/tests/ -v --cov=app --cov-report=term-missing
        env:
          LAUNCHES_TABLE_NAME: test-table
          AWS_DEFAULT_REGION: us-east-1

      - name: Upload coverage reports
        if: always()
        uses: codecov/codecov-action@v4
        with:
          files: ./backend/.coverage
          flags: backend
          name: backend-coverage
        continue-on-error: true

  # ==================================================
  # Job 3: Build, Push to ECR & Deploy to ECS
  # ==================================================
  deploy:
    name: Build & Deploy to AWS
    runs-on: ubuntu-latest
    needs: [test-lambda, test-backend]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building Docker image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "Pushing to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Download current task definition
        run: |
          aws ecs describe-task-definition \
            --task-definition ${{ env.ECS_TASK_DEFINITION }} \
            --query taskDefinition > task-definition.json

      - name: Fill in the new image ID in the Amazon ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: ${{ env.CONTAINER_NAME }}
          image: ${{ steps.build-image.outputs.image }}

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Register new task with ALB
        run: |
          echo "ğŸ”„ Registering new ECS task with ALB target group..."
          
          # ALB configuration
          ALB_ARN="arn:aws:elasticloadbalancing:us-east-1:647376275168:loadbalancer/app/spacex-alb/6a5c9f5e86d7cbf9"
          TG_ARN="arn:aws:elasticloadbalancing:us-east-1:647376275168:targetgroup/spacex-tg/6a88133919d7bacc"
          
          # Wait for new task to be running
          sleep 30
          
          # Get the new task ARN
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --desired-status RUNNING \
            --region ${{ env.AWS_REGION }} \
            --query 'taskArns[0]' \
            --output text)
          
          if [ "$TASK_ARN" == "None" ] || [ -z "$TASK_ARN" ]; then
            echo "âŒ No running task found"
            exit 1
          fi
          
          echo "ğŸ“‹ Task: $TASK_ARN"
          
          # Get task network interface
          ENI_ID=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --tasks $TASK_ARN \
            --region ${{ env.AWS_REGION }} \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
            --output text)
          
          # Get private IP and subnet
          NETWORK_INFO=$(aws ec2 describe-network-interfaces \
            --network-interface-ids $ENI_ID \
            --region ${{ env.AWS_REGION }} \
            --query 'NetworkInterfaces[0].[PrivateIpAddress,SubnetId]' \
            --output text)
          
          PRIVATE_IP=$(echo $NETWORK_INFO | awk '{print $1}')
          TASK_SUBNET=$(echo $NETWORK_INFO | awk '{print $2}')
          
          echo "ğŸŒ Private IP: $PRIVATE_IP"
          echo "ğŸ“ Subnet: $TASK_SUBNET"
          
          # Get task AZ
          TASK_AZ=$(aws ec2 describe-subnets \
            --subnet-ids $TASK_SUBNET \
            --region ${{ env.AWS_REGION }} \
            --query 'Subnets[0].AvailabilityZone' \
            --output text)
          
          echo "ğŸŒ Task AZ: $TASK_AZ"
          
          # Get current ALB subnets and AZs
          ALB_SUBNETS=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns $ALB_ARN \
            --region ${{ env.AWS_REGION }} \
            --query 'LoadBalancers[0].AvailabilityZones[*].SubnetId' \
            --output text)
          
          ALB_AZS=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns $ALB_ARN \
            --region ${{ env.AWS_REGION }} \
            --query 'LoadBalancers[0].AvailabilityZones[*].ZoneName' \
            --output text)
          
          # Check if task AZ is in ALB AZs
          if ! echo "$ALB_AZS" | grep -q "$TASK_AZ"; then
            echo "âš ï¸  Task AZ ($TASK_AZ) not in ALB AZs, adding it..."
            
            # Task subnet is already in the correct AZ, add it to ALB
            aws elbv2 set-subnets \
              --load-balancer-arn $ALB_ARN \
              --subnets $ALB_SUBNETS $TASK_SUBNET \
              --region ${{ env.AWS_REGION }}
            
            echo "âœ… Added subnet $TASK_SUBNET to ALB"
            sleep 10
          else
            echo "âœ… Task AZ ($TASK_AZ) already in ALB"
          fi
          
          # Deregister old targets
          echo "ğŸ—‘ï¸  Deregistering old targets..."
          OLD_TARGETS=$(aws elbv2 describe-target-health \
            --target-group-arn $TG_ARN \
            --region ${{ env.AWS_REGION }} \
            --query 'TargetHealthDescriptions[].Target.Id' \
            --output text)
          
          for OLD_IP in $OLD_TARGETS; do
            if [ "$OLD_IP" != "$PRIVATE_IP" ]; then
              aws elbv2 deregister-targets \
                --target-group-arn $TG_ARN \
                --targets Id=$OLD_IP \
                --region ${{ env.AWS_REGION }} 2>/dev/null || true
              echo "  âœ“ Deregistered: $OLD_IP"
            fi
          done
          
          # Register new target
          echo "âœ¨ Registering new target..."
          aws elbv2 register-targets \
            --target-group-arn $TG_ARN \
            --targets Id=$PRIVATE_IP,Port=8000 \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Target registered: $PRIVATE_IP:8000"
          
          # Wait for health check
          echo "â³ Waiting for health check (30s)..."
          sleep 30
          
          # Check health status
          HEALTH_STATUS=$(aws elbv2 describe-target-health \
            --target-group-arn $TG_ARN \
            --targets Id=$PRIVATE_IP,Port=8000 \
            --region ${{ env.AWS_REGION }} \
            --query 'TargetHealthDescriptions[0].TargetHealth.State' \
            --output text)
          
          echo "ğŸ¥ Health status: $HEALTH_STATUS"

      - name: Deployment summary
        run: |
          echo "âœ… Deployment completed successfully!"
          echo "ğŸ“¦ Image: ${{ steps.build-image.outputs.image }}"
          echo "ğŸš€ Service: ${{ env.ECS_SERVICE }}"
          echo "ğŸ¯ Cluster: ${{ env.ECS_CLUSTER }}"
          echo "ğŸŒ Application: http://spacex-alb-307099083.us-east-1.elb.amazonaws.com"
          echo "ğŸ“š API Docs: http://spacex-alb-307099083.us-east-1.elb.amazonaws.com/docs"
